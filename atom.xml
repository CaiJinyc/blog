<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CaiJinyc&#39;s Blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://caijin.tech/blog/"/>
  <updated>2018-06-08T15:26:36.926Z</updated>
  <id>http://caijin.tech/blog/</id>
  
  <author>
    <name>CaiJinyc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 二叉搜索树</title>
    <link href="http://caijin.tech/blog/2018/06/06/2018-06-08-JS%E4%BA%8C%E6%90%9C%E7%B4%A2%E5%8F%89%E6%A0%91/"/>
    <id>http://caijin.tech/blog/2018/06/06/2018-06-08-JS二搜索叉树/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2018-06-08T15:26:36.926Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 本文包括：二叉搜索树（创建、遍历、搜索、插入等）、JavaScript 实现翻转二叉树<br><a id="more"></a></p></blockquote><h2 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h2><p><strong>二叉树的定义：</strong>二叉树的每个结点至多只有二棵子树（不存在度大于2的结点），二叉树的子树有左右之分，次序不能颠倒。</p><p><strong>二叉查找树（BST）：</strong>又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉查找树是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。</p><h2 id="创建一个二叉查找树"><a href="#创建一个二叉查找树" class="headerlink" title="创建一个二叉查找树"></a>创建一个二叉查找树</h2><p>首先创建一个 <code>BinarySearchTree</code> 类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了 ES6 的 Class 语法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node(key) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> right = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      key,</span><br><span class="line">      left,</span><br><span class="line">      right</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下二叉查找树的数据结构组织方式（没有找到二叉搜索树的先用二叉树的代替一下）：</p><p><img src="http://p87llnk7g.bkt.clouddn.com/18-6-8/86417615.jpg" alt=""></p><p>二叉树是通过指针（指向下一个节点）来表示节点之间的关系的，所以需要在声明 Node 的时候，定义两个指针，一个指向左边，一个指向右边。 还需要声明一个 root 来保存树的根元素。</p><h2 id="向树中插入一个键（节点）"><a href="#向树中插入一个键（节点）" class="headerlink" title="向树中插入一个键（节点）"></a>向树中插入一个键（节点）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>  </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  insert (key) &#123;</span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="keyword">this</span>.Node(key)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果根节点为空，那么插入的节点就为根节点</span></span><br><span class="line">      <span class="keyword">this</span>.root = newNode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果根节点不为空</span></span><br><span class="line">      <span class="keyword">this</span>.insertNode(<span class="keyword">this</span>.root, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  insertNode (node, newNode) &#123;</span><br><span class="line">    <span class="comment">// 当新节点比父节点小，插入左边</span></span><br><span class="line">    <span class="keyword">if</span> (newNode.key &lt; node.key) &#123;</span><br><span class="line">      <span class="comment">// 左边没有内容则插入</span></span><br><span class="line">      <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.left = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有内容就继续递归，直到没有内容然后可以插入</span></span><br><span class="line">        <span class="keyword">this</span>.insertNode(node.left, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 右边和左边相同，不重复说明</span></span><br><span class="line">      <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.right = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.insertNode(node.right, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为使用了 class 所以没有学过 class 的同学可以先看一下 ES6 的 class，再来看文章。</p><p>仔细分析上面的代码，多看几遍就可以了解其中的奥妙（也可以自己在游览器中运行一下，插入几个值试一下）。</p><p>运行一遍试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line">m.insert(<span class="number">5</span>)</span><br><span class="line">m.insert(<span class="number">4</span>)</span><br><span class="line">m.insert(<span class="number">3</span>)</span><br><span class="line">m.insert(<span class="number">6</span>)</span><br><span class="line">m.insert(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>会得到这样的结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  key: <span class="number">5</span>,</span><br><span class="line">  left: &#123;</span><br><span class="line">    key: <span class="number">4</span>,</span><br><span class="line">    left: &#123;</span><br><span class="line">      key: <span class="number">3</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    right: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  right: &#123;</span><br><span class="line">    key: <span class="number">6</span>,</span><br><span class="line">    left: <span class="literal">null</span>,</span><br><span class="line">    right: &#123;</span><br><span class="line">      key: <span class="number">7</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmm，真复杂（自己看的都头晕），还是画个图吧。</p><p><img src="http://p87llnk7g.bkt.clouddn.com/18-6-8/17343352.jpg" alt=""></p><p>会生成这样一个二叉查找树~，插入功能就算完成啦！</p><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。访问树会有三种方法：中序、先序、后续。下面分别讲解</p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是从最小到最大的顺序进行访问所有节点。具体方法，看代码吧，配上图多看两遍代码就能明白了（我是这么认为的）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>  </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  inOrderTraverse (callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.inOrderTraverseNode(<span class="keyword">this</span>.root, callback)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  inOrderTraverseNode (node, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.inOrderTraverseNode(node.left, callback)</span><br><span class="line">      callback(node.key)</span><br><span class="line">      <span class="keyword">this</span>.inOrderTraverseNode(node.right, callback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，用图展示一下遍历的过程，具体过程看代码多思考一下。</p><p><img src="http://p87llnk7g.bkt.clouddn.com/18-6-8/62900257.jpg" alt=""></p><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>先序遍历会先访问节点本身，然后再访问它的左侧子节点，最后再访问右侧的节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>  </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  preOrderTraverse (callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.preOrderTraverseNode(<span class="keyword">this</span>.root, callback)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  preOrderTraverseNode (node, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      callback(node.key)</span><br><span class="line">      <span class="keyword">this</span>.preOrderTraverseNode(node.left, callback)</span><br><span class="line">      <span class="keyword">this</span>.preOrderTraverseNode(node.right, callback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看代码，发现和中序遍历的区别不过是先执行了 <code>callback</code> 然后再遍历左右。</p><p><img src="http://p87llnk7g.bkt.clouddn.com/18-6-8/3812727.jpg" alt=""></p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历则是先访问节点的后代节点，然后再访问节点本身。实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>  </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  postOrderTraverse (callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.postOrderTraverseNode(<span class="keyword">this</span>.root, callback)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  postOrderTraverseNode (node, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.postOrderTraverseNode(node.left, callback)</span><br><span class="line">      <span class="keyword">this</span>.postOrderTraverseNode(node.right, callback)</span><br><span class="line">      callback(node.key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再仔细看代码，发现和中序遍历的区别不过是先执行了遍历了左右，最后执行了 <code>callback</code> 。</p><p>惯例，画张图~</p><p><img src="http://p87llnk7g.bkt.clouddn.com/18-6-8/67391855.jpg" alt=""></p><p>三种遍历方式讲完啦，不懂的可以多看几遍代码哦~</p><h2 id="搜索二叉搜索树中的值"><a href="#搜索二叉搜索树中的值" class="headerlink" title="搜索二叉搜索树中的值"></a>搜索二叉搜索树中的值</h2><p>在树中，通常有三种经常使用的搜索类型：</p><ul><li>搜索最大值</li><li>搜索最小值</li><li>搜索特定值</li></ul><p>下面一一列举</p><h3 id="搜索最小和最大值"><a href="#搜索最小和最大值" class="headerlink" title="搜索最小和最大值"></a>搜索最小和最大值</h3><p>首先我们知道二叉搜索树中的最小值在最左边，最大值在最右边。既然知道这个，那么实现搜索最大和最小就十分简单了。所以直接上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>  </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 搜索最小</span></span><br><span class="line">  min () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.minNode(<span class="keyword">this</span>.root)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  minNode (node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="comment">// 如果节点存在，而且左边不为 null</span></span><br><span class="line">      <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> node.key</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果树为空，则返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 搜索最大</span></span><br><span class="line">  max () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.maxNode(<span class="keyword">this</span>.root)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  maxNode (node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="keyword">while</span> (node &amp;&amp; node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.right</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node.key</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索特定的值"><a href="#搜索特定的值" class="headerlink" title="搜索特定的值"></a>搜索特定的值</h3><p>基本上的思路和遍历节点差不多，具体看代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>  </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  search (key) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(<span class="keyword">this</span>.root, key)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  searchNode (node, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 key 比节点的值小，那么搜索左边的子节点，下面的相反</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(node.left, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(node.right, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 本文包括：二叉搜索树（创建、遍历、搜索、插入等）、JavaScript 实现翻转二叉树&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://caijin.tech/blog/tags/JavaScript/"/>
    
      <category term="数据结构" scheme="http://caijin.tech/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JS 事件委托</title>
    <link href="http://caijin.tech/blog/2018/05/25/2018-5-25-event-bind/"/>
    <id>http://caijin.tech/blog/2018/05/25/2018-5-25-event-bind/</id>
    <published>2018-05-24T16:00:00.000Z</published>
    <updated>2018-05-25T14:21:25.777Z</updated>
    
    <content type="html"><![CDATA[<p>面试被问到事件委托了，虽然很早之前就使用过事件委托，但是面试的时候居然没有能够讲清楚，再总结一下吧。<br><a id="more"></a></p><blockquote><p>第一次经历面试，真的很紧张，很多自己明明会的东西也说不清，实在是丢脸。面试估计已经凉凉 了，吸取一下教训吧，学习的时候一定要学习扎实了。</p></blockquote><h2 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h2><p>事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。</p><p>引用个的例子：</p><blockquote><p>有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。</p></blockquote><p><strong>那么为什么需要事件委托：</strong></p><ul><li>优点1: 提高 JavaScript 性能。事件委托可以显著的提高事件的处理速度，减少内存的占用。</li><li>优点2: 动态的添加DOM元素，不需要因为元素的改动而修改事件绑定。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>传统写法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"list"</span>&gt;</span><br><span class="line">  &lt;li id=<span class="string">"item1"</span>&gt;item1&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li id="item2"&gt;item2&lt;/</span>li&gt;</span><br><span class="line">  &lt;li id=<span class="string">"item3"</span>&gt;item3&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">let</span> item1 = <span class="built_in">document</span>.getElementById(<span class="string">"item1"</span>);</span><br><span class="line">  <span class="keyword">let</span> item2 = <span class="built_in">document</span>.getElementById(<span class="string">"item2"</span>);</span><br><span class="line">  <span class="keyword">let</span> item3 = <span class="built_in">document</span>.getElementById(<span class="string">"item3"</span>);</span><br><span class="line"></span><br><span class="line">  item1.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">"hello item1"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  item2.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">"hello item2"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  item3.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">"hello item3"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>试想，如果需要绑定 100 个 <code>li</code> 元素，那么岂不是需要绑定 100 个事件（浪费内存）。</li><li>当添加一个 DOM 元素的时候，传统的写法还需要再绑定新添加的 DOM。</li></ul><p><strong>事件委托</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"list"</span>&gt;</span><br><span class="line">  &lt;li id=<span class="string">"item1"</span>&gt;item1&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li id="item2"&gt;item2&lt;/</span>li&gt;</span><br><span class="line">  &lt;li id=<span class="string">"item3"</span>&gt;item3&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#list'</span>);</span><br><span class="line">  ul.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello '</span> + event.target.innerText)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>利用事件委托，只需要给父元素添加了事件，就可以给所有 <code>li</code> 绑定事件，而不必要给每个 <code>li</code> 分别添加事件。这样就非常节省内存了，也很方便。</p><p>同时实现了动态添加 DOM 的时候不需要再添加事件。例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"list"</span>&gt;</span><br><span class="line">  &lt;li id=<span class="string">"item1"</span>&gt;item1&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li id="item2"&gt;item2&lt;/</span>li&gt;</span><br><span class="line">  &lt;li id=<span class="string">"item3"</span>&gt;item3&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#list'</span>);</span><br><span class="line">  ul.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello '</span> + event.target.innerText)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> newVal = <span class="string">`&lt;li id="item4"&gt;item4&lt;/li&gt;`</span></span><br><span class="line">  ul.innerHTML = ul.innerHTML + newVal</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>这个时候点击新添加的 item4 会发现打印了 <code>hello item4</code> 说明 item4 绑定了事件，即事件委托可以为新添加的 DOM 元素动态的添加事件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试被问到事件委托了，虽然很早之前就使用过事件委托，但是面试的时候居然没有能够讲清楚，再总结一下吧。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://caijin.tech/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS 的深拷贝和浅拷贝总结</title>
    <link href="http://caijin.tech/blog/2018/05/20/2018-5-20-arr-copy/"/>
    <id>http://caijin.tech/blog/2018/05/20/2018-5-20-arr-copy/</id>
    <published>2018-05-19T16:00:00.000Z</published>
    <updated>2018-05-25T14:20:05.168Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下深复制和浅复制的区别，以及实现他们的方法。<br><a id="more"></a></p><h2 id="浅复制和深复制的区别"><a href="#浅复制和深复制的区别" class="headerlink" title="浅复制和深复制的区别"></a>浅复制和深复制的区别</h2><p>对于<strong>基本类型</strong>（Undefined、Null、Boolean、Number 和 String），浅复制是对值的复制，对于<strong>引用类型</strong>来说，浅复制是对地址的复制，那么对于地址的复制又是什么意思呢？一段代码解释一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr1</span><br><span class="line">arr1.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr1) <span class="comment">//  [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">//  [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只改变了 arr1，但是 arr2 也同时改变了。为什么呢？</span></span><br><span class="line"><span class="comment">// 因为 arr2 复制的仅仅是 arr1 的地址（指向数据的位置），所以 arr1 和 arr2 引用的是相同的数据</span></span><br><span class="line"><span class="comment">// 所以改变 arr1 的值时，arr2 也会发生改变</span></span><br></pre></td></tr></table></figure><p>而深复制则是开辟新的栈，两个属性对应两个不同的地址，修改一个属性的数据，不会改变另一个属性数据。</p><h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>:<span class="number">1</span>, <span class="attr">arr</span>: [<span class="number">2</span>,<span class="number">3</span>] &#125;;</span><br><span class="line"><span class="keyword">let</span> shallowObj = shallowCopy(obj);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dst = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> src) &#123;</span><br><span class="line">    <span class="keyword">if</span> (src.hasOwnProperty(prop)) &#123;</span><br><span class="line">      dst[prop] = src[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.arr.push(<span class="string">'4'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.arr) <span class="comment">// [2, 3, "4"]</span></span><br><span class="line"><span class="built_in">console</span>.log(shallowObj.arr) <span class="comment">// [2, 3, "4"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 明明只是修改了 obj 的 arr，但是 shallowObj 中的也被修改了。</span></span><br></pre></td></tr></table></figure><p>原因：因为浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅复制会导致 obj.arr 和 shallowObj.arr 指向同一块内存地址。</p><h2 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h2><h3 id="1-JSON实现"><a href="#1-JSON实现" class="headerlink" title="1. JSON实现"></a>1. JSON实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br></pre></td></tr></table></figure><p>这个方法最方便，但是有它的局限性。</p><ul><li>无法复制函数</li><li>原型链没了，对象就是 object，所属的类没了。</li></ul><p>那么为什么不能复制函数呢？<em>因为：JSON.stringify 函数将一个 JavaScript 对象转换成文本化的 JSON。不能被文本化的属性会被忽略。所以函数就被忽略调了。</em></p><h3 id="2-递归实现"><a href="#2-递归实现" class="headerlink" title="2. 递归实现"></a>2. 递归实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归深拷贝！</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newVal;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'Array'</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个空的数组</span></span><br><span class="line">    newVal = [];</span><br><span class="line">    <span class="keyword">let</span> i = val.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      newVal[i] = clone(val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newVal;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'Object'</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个空对象</span></span><br><span class="line">    newVal = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> val) &#123;</span><br><span class="line">      <span class="comment">// 为这个对象添加新的属性</span></span><br><span class="line">      newVal[k] = clone(val[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newVal;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现的原理</strong></p><p>实现原理，先新建一个空对象，内存中新开辟一块地址，把被复制对象的所有可枚举的（注意可枚举的对象） 属性方法一一复制过来，注意要用递归（如果传入的变量是一个数组或者对象，那么就进行递归）来复制子对象里面的所有属性和方法，直到子子…..属性为基本数据类型。</p><p>总结，深拷贝需要理解两点：</p><ol><li>新开辟内存地址</li><li>递归来刨根复制</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下深复制和浅复制的区别，以及实现他们的方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://caijin.tech/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue 实现网易云音乐 WebApp</title>
    <link href="http://caijin.tech/blog/2018/05/15/2018-5-15-vue-music.1/"/>
    <id>http://caijin.tech/blog/2018/05/15/2018-5-15-vue-music.1/</id>
    <published>2018-05-14T16:00:00.000Z</published>
    <updated>2018-05-23T15:56:38.696Z</updated>
    
    <content type="html"><![CDATA[<p>基于 Vue(2.5) + vuex + vue-router + vue-axios +better-scroll + Scss + ES6 等开发一款移动端音乐 WebApp，UI 界面参考了安卓版的网易云音乐、flex 布局适配常见移动端。<br><a id="more"></a><br>项目演示地址：<a href="http://120.79.162.149:3002" target="_blank" rel="noopener">移动端音乐 WebApp</a>，或者可以扫描二维码访问：</p><p><img src="http://p87llnk7g.bkt.clouddn.com/18-5-15/34474412.jpg" alt=""></p><ul><li>推荐使用手机预览，电脑在 Chrome 调试模式下食用效果更佳，开启调试模式的手机模式后，如果不能滚动，刷新一下页面即可</li></ul><p>源码地址：<a href="https://github.com/CaiJinyc/vue-music-webapp" target="_blank" rel="noopener">vue-music-webapp</a>，欢迎 star 和 fork 哦~</p><blockquote><p> 如果你觉得我做的不错的话，我就厚着脸皮求个 <strong>star</strong> ⭐️ 哈，<strong>star</strong> 是对我最大的鼓励（老脸一红）</p></blockquote><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>图片虽然压缩过了，但是几张加载一起还是有 3MB 左右，所以请耐心等待一下啦:joy:。感觉不错的可以去上面的地址体验一下呦~</p><h4 id="推荐、排行榜、歌手"><a href="#推荐、排行榜、歌手" class="headerlink" title="推荐、排行榜、歌手"></a>推荐、排行榜、歌手</h4><p><img src="http://p87llnk7g.bkt.clouddn.com/18-5-15/21667995.jpg" alt="推荐、排行、歌手"></p><h4 id="歌单详情、个人中心"><a href="#歌单详情、个人中心" class="headerlink" title="歌单详情、个人中心"></a>歌单详情、个人中心</h4><p><img src="http://p87llnk7g.bkt.clouddn.com/18-5-15/4430556.jpg" alt="详情页面"></p><h4 id="播放器、播放列表"><a href="#播放器、播放列表" class="headerlink" title="播放器、播放列表"></a>播放器、播放列表</h4><p><img src="http://p87llnk7g.bkt.clouddn.com/18-5-15/81352770.jpg" alt="播放器"></p><h4 id="搜索页面"><a href="#搜索页面" class="headerlink" title="搜索页面"></a>搜索页面</h4><p><img src="http://p87llnk7g.bkt.clouddn.com/18-5-15/77000462.jpg" alt="搜索"></p><h2 id="开发目的"><a href="#开发目的" class="headerlink" title="开发目的"></a>开发目的</h2><p>通过学习开发一个 Vue 全家桶项目，让自己更熟练的使用 Vue 全家桶、模块化开发、ES6 等等知识，提高自己的技术能力。</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p><strong>前端</strong></p><ul><li><code>Vue</code>：用于构建用户界面的 MVVM 框架</li><li><code>vue-router</code>：为单页面应用提供的路由系统，使用了 <code>Lazy Loading Routes</code> 技术来实现异步加载优化性能</li><li><code>vuex</code>：Vue 集中状态管理，在多个组件共享某些状态时非常便捷</li><li><code>vue-lazyload</code>：实现图片懒加载，节省用户流量，优化页面加载速度</li><li><code>better-scroll</code>：解决移动端各种滚动场景需求的插件，使移动端滑动体验更加流畅</li><li><code>SCSS</code>：css 预编译处理器</li><li><code>ES6</code>：ECMAScript 新一代语法，模块化、解构赋值、Promise、Class 等方法非常好用</li></ul><p><strong>后端</strong></p><ul><li><code>Node.js</code>：利用 Express 搭建的本地测试服务器</li><li><code>vue-axios</code>：用来请求后端 API 音乐数据</li><li><code>NeteaseCloudMusicApi</code>：网易云音乐 NodeJS 版 API，提供音乐数据</li></ul><p><strong>其他工具</strong></p><ul><li><code>vue-cli</code>：Vue 脚手架工具，快速初始化项目代码</li><li><code>eslint</code>：代码风格检查工具，帮助我们规范代码书写（一定要养成良好的代码规范）</li><li><code>iconfont</code> ：阿里巴巴图标库，谁用谁知道</li><li><code>fastclick</code> ：消除 click 移动游览器 300ms 的延</li></ul><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><p>播放器内核、推荐页面、热榜页面、歌手页面、歌单详情、歌手详情、排行榜详情、搜索页面、播放列表、用户中心等等功能。</p><h3 id="推荐页面"><a href="#推荐页面" class="headerlink" title="推荐页面"></a>推荐页面</h3><p>推荐页分成三个部分，分别是 banner 轮播图、推荐歌单、推荐歌曲，数据都是使用 <code>axios</code> 请求 API 获取得到的，图片都使用 <code>vue-lazyload</code> 实现懒加载。</p><p>轮播图：使用 <code>better-scroll</code> 实现，具体可以看这里 <a href="https://ustbhuangyi.github.io/better-scroll/doc/zh-hans/options-advanced.html#```snap```" target="_blank" rel="noopener">Slide</a> 。<em>点击跳转方面只实现歌曲和歌单的跳转，因为暂时只实现了这两个功能。</em></p><p>推荐歌单，推荐歌曲：使用 <code>vuex</code> 管理数据，方便组件之间的数据交互（播放器播放歌曲）。因为数据上还有播放数量，所以就顺便也加上去了。</p><h3 id="排行榜页面"><a href="#排行榜页面" class="headerlink" title="排行榜页面"></a>排行榜页面</h3><p>同样是通过 API 获取到排行榜的数据，但是因为 API 获取到的是排行榜中所有歌曲的数据，所以难免在加载速度上有点慢，后期再看能不能优化一下，加载的慢毕竟太影响用户体验了，别的就没什么了。</p><h3 id="歌手页面"><a href="#歌手页面" class="headerlink" title="歌手页面"></a>歌手页面</h3><p>实现歌手列表的左右联动（这个需要理解理解），因为之前已经写过和这个有关的博客，所以就不多写了，具体可以看我之前的这个笔记 <a href="http://caijin.tech/blog/2018/04/23/2018-4-23-list-view/">移动端字母索引导航</a> 。</p><h3 id="歌曲列表组件"><a href="#歌曲列表组件" class="headerlink" title="歌曲列表组件"></a>歌曲列表组件</h3><p>用来显示歌曲列表，在很多的地方都进行了复用，例如：歌单详情页、排行榜详情页、歌手详情页、搜索结果、用户中心等等。</p><h3 id="歌单详情页"><a href="#歌单详情页" class="headerlink" title="歌单详情页"></a>歌单详情页</h3><p>通过歌单的 ID 来获取歌单中的歌曲数据，然后还做了一些体验上面的交互，比如上滑显示状态栏然后将状态栏标题变为歌单名，具体可以尝试一下就知道了。</p><p>然后就是复用 歌曲列表组建 来显示歌曲。</p><h3 id="排行榜详情、歌手详情"><a href="#排行榜详情、歌手详情" class="headerlink" title="排行榜详情、歌手详情"></a>排行榜详情、歌手详情</h3><p>和歌单详情基本上没有什么区别，除了 UI 界面方面有细微的改动（根据不同的内容作出不同的优化）。</p><h3 id="播放器"><a href="#播放器" class="headerlink" title="播放器"></a>播放器</h3><p>最最最重要的组件，毕竟是个音乐播放器，不能放歌那啥都是扯淡了。</p><p>实现功能：顺序播放、单曲循环、随机播放、收藏等。</p><p>播放、暂停使用 HTML5 的 audio 实现。</p><p>数据、播放状态、播放历史、习惯歌曲等方面使用了 <code>vuex</code> 来进行管理，因为数据太多，组件直接传递的话是会死人的，所以还是老老实实的用 <code>vuex</code> 吧，数据之前的传递真的很方便。</p><p>图标使用 <code>iconfont</code> 阿里巴巴图标库，中间的唱片旋转动画使用了 <code>animation</code> 实现。</p><p>歌词部分获取到网易的歌词数据，然后使用 第三方库 <a href="https://github.com/ustbhuangyi/lyric-parser" target="_blank" rel="noopener"><code>lyric-parser</code></a> 进行处理。实现显示歌词、拖动进度条歌词同步滚动、歌词跟随歌曲进度高亮。</p><p>通过 <code>localstorage</code> 存储喜欢歌曲、播放历史数据。</p><h4 id="audio-标签在移动端不能够自动播放的问题"><a href="#audio-标签在移动端不能够自动播放的问题" class="headerlink" title="audio 标签在移动端不能够自动播放的问题"></a>audio 标签在移动端不能够自动播放的问题</h4><p>电脑端是没有这个问题的，这个问题真的是让我很头大，最后是用了很鬼畜的方法解决了（使用 <code>addEventListener</code> 监听 touchend 事件，然后在回调函数中让 audio 播放一次，具体看 App.vue 文件，注释有写）。</p><h3 id="播放列表"><a href="#播放列表" class="headerlink" title="播放列表"></a>播放列表</h3><p>显示和管理当前播放歌曲，可以用来删除列表中的歌曲、以及选择播放歌曲。</p><h3 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h3><p>实现功能：搜索歌手、歌单、歌曲、热门搜索、数据节流、上拉刷新、保存搜索记录。</p><p>通过关键字请求 API 获取搜索数据，显示歌手、歌单、歌曲。</p><p>实现了上刷新，因为搜索可以设置请求数据的条数，所以可以用来实现上刷新的功能。</p><p>通过节流函数实现数据节流，通过 <code>localstorage</code> 存储搜索数据。</p><h3 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h3><p>将在本地存储的数据显示出来，方便用户使用，后期准备添加更多功能。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol><li>优化排行榜加载速度</li><li>优化重复代码</li><li>增加歌曲评论</li><li>增加 MV、电台 功能</li><li>emm，更多功能容我再想想哈</li></ol><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><ul><li>感谢 <a href="https://github.com/Binaryify" target="_blank" rel="noopener">Binaryify</a> 对接口文档 <a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/?id=neteasecloudmusicapi" target="_blank" rel="noopener">NeteaseCloudMusicApi</a> 的不断维护与更新。</li><li>感谢 <a href="https://github.com/ustbhuangyi" target="_blank" rel="noopener">ustbhuangyi</a> 老师的 <a href="http://coding.imooc.com/class/107.html" target="_blank" rel="noopener">Vue 实战教程</a> ，让我学习到很多 vue 的知识。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后的最后当然是厚着脸皮的再求个 star 啦，如果觉得我的项目还不错的话，就给个 ⭐️ 鼓励一下吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于 Vue(2.5) + vuex + vue-router + vue-axios +better-scroll + Scss + ES6 等开发一款移动端音乐 WebApp，UI 界面参考了安卓版的网易云音乐、flex 布局适配常见移动端。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://caijin.tech/blog/tags/JavaScript/"/>
    
      <category term="移动端" scheme="http://caijin.tech/blog/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://caijin.tech/blog/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>移动端字母索引导航</title>
    <link href="http://caijin.tech/blog/2018/04/23/2018-4-23-list-view/"/>
    <id>http://caijin.tech/blog/2018/04/23/2018-4-23-list-view/</id>
    <published>2018-04-22T16:00:00.000Z</published>
    <updated>2018-05-02T14:30:51.347Z</updated>
    
    <content type="html"><![CDATA[<p><strong>vue</strong> + <strong>better-scroll</strong> 实现移动端歌手列表字母索引导航。算是一个学习笔记吧，写个笔记让自己了解的更加深入一点。<a id="more"></a></p><p>Demo： <a href="http://caijin.tech/demo/list-view/index.html#/">list-view</a>，使用 chrome 手机模式查看。换成手机模式之后，不能滑动的话，刷新一下就 OK 了。</p><p>Github：<a href="https://github.com/CaiJinyc/demo/tree/master/list-view" target="_blank" rel="noopener">移动端字母索引导航</a></p><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://hexo-image.oss-cn-shenzhen.aliyuncs.com/18-5-2/19433704.jpg" alt=""></p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>因为用到的是 vue-cli 和 better-scroll，所以首先要安装 vue-cli，然后再 npm 安装 <a href="https://ustbhuangyi.github.io/better-scroll/doc/zh-hans/installation.html#npm" target="_blank" rel="noopener">better-scroll</a>。</p><p>简单介绍一下 better-scroll：</p><blockquote><p>better-scroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。它的核心是借鉴的 iscroll 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。</p><p>better-scroll 是基于原生 JS 实现的，不依赖任何框架。它编译后的代码大小是 63kb，压缩后是 35kb，gzip 后仅有 9kb，是一款非常轻量的 JS lib。</p></blockquote><p>除了这两，还使用 scss、vue-lazyload。scss 预处理器，大家都懂，用别的也一样。lazyload 实现懒加载，不用也可以，主要是优化一下体验。</p><p>数据直接使用了网易云的歌手榜单。</p><p><em>CSS 样式我就不贴了，直接看源码就可以了。</em></p><h2 id="实现基本样式"><a href="#实现基本样式" class="headerlink" title="实现基本样式"></a>实现基本样式</h2><p>直接使用 v-for 和 双侧嵌套实现歌手列表、以及右侧索引栏。</p><p>HTML 结构：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"group in singers"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"list-group"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:key</span>=<span class="string">"group.id"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">"listGroup"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"list-group-title"</span>&gt;</span>&#123;&#123; group.title &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in group.items"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"list-group-item"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-lazy</span>=<span class="string">"item.avatar"</span> <span class="attr">class</span>=<span class="string">"avatar"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"name"</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-shortcut"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in shortcutList"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:data-index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">"item.id"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>shortcutList 是通过计算属性得到的，取 title 的第一个字符即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shortcutList () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.singers.map(<span class="function">(<span class="params">group</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> group.title.substr(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-better-scroll"><a href="#使用-better-scroll" class="headerlink" title="使用 better-scroll"></a>使用 better-scroll</h2><p>使用 better-scroll 实现滚动。对了，使用的时候别忘了用 import 引入。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="comment">// 初始化 better-scroll 必须要等 dom 加载完毕</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._initSrcoll()</span><br><span class="line">  &#125;, <span class="number">20</span>)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  _initSrcoll () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'didi'</span>)</span><br><span class="line">    <span class="keyword">this</span>.scroll = <span class="keyword">new</span> BScroll(<span class="keyword">this</span>.$refs.listView, &#123;</span><br><span class="line">      <span class="comment">// 获取 scroll 事件，用来监听。</span></span><br><span class="line">      probeType: <span class="number">3</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 created 方法进行 better-scroll 初始化，使用 setTimeout 是因为需要等到 DOM 加载完毕。不然 better-scroll 获取不到 dom 就会初始化失败。</p><p><em>这里把方法写在两 methods 里面，这样就不会看起来很乱，直接调用就可以了。</em></p><blockquote><p>初始化的时候传入两 probeType: 3，解释一下：当 probeType 为 3 的时候，不仅在屏幕滑动的过程中，而且在 momentum 滚动动画运行过程中实时派发 scroll 事件。如果没有设置该值，其默认值为 0，即不派发 scroll 事件。</p></blockquote><h2 id="给索引添加点击事件和移动事件实现跳转"><a href="#给索引添加点击事件和移动事件实现跳转" class="headerlink" title="给索引添加点击事件和移动事件实现跳转"></a>给索引添加点击事件和移动事件实现跳转</h2><p>首先需要给索引绑定一个 touchstart 事件（当在屏幕上按下手指时触发），直接使用 v-on 就可以了。然后还需要给索引添加一个 data-index 这样就可以获取到索引的值，使用 <code>:data-index=&quot;index&quot;</code>。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-shortcut"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in shortcutList"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:data-index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">"item.id"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">touchstart</span>=<span class="string">"onShortcutStart"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">touchmove.stop.prevent</span>=<span class="string">"onShortcutMove"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>绑定一个 onShortcutStart 方法。实现点击索引跳转的功能。再绑定一个 onShortcutMove 方法，实现滑动跳转。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="comment">// 添加一个 touch 用于记录移动的属性</span></span><br><span class="line">  <span class="keyword">this</span>.touch = &#123;&#125;</span><br><span class="line">  <span class="comment">// 初始化 better-scroll 必须要等 dom 加载完毕</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._initSrcoll()</span><br><span class="line">  &#125;, <span class="number">20</span>)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  _initSrcoll () &#123;</span><br><span class="line">    <span class="keyword">this</span>.scroll = <span class="keyword">new</span> BScroll(<span class="keyword">this</span>.$refs.listView, &#123;</span><br><span class="line">      probeType: <span class="number">3</span>,</span><br><span class="line">      click: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onShortcutStart (e) &#123;</span><br><span class="line">    <span class="comment">// 获取到绑定的 index</span></span><br><span class="line">    <span class="keyword">let</span> index = e.target.getAttribute(<span class="string">'data-index'</span>)</span><br><span class="line">    <span class="comment">// 使用 better-scroll 的 scrollToElement 方法实现跳转</span></span><br><span class="line">    <span class="keyword">this</span>.scroll.scrollToElement(<span class="keyword">this</span>.$refs.listGroup[index])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录一下点击时候的 Y坐标 和 index</span></span><br><span class="line">    <span class="keyword">let</span> firstTouch = e.touches[<span class="number">0</span>].pageY</span><br><span class="line">    <span class="keyword">this</span>.touch.y1 = firstTouch</span><br><span class="line">    <span class="keyword">this</span>.touch.anchorIndex = index</span><br><span class="line">  &#125;,</span><br><span class="line">  onShortcutMove (e) &#123;</span><br><span class="line">    <span class="comment">// 再记录一下移动时候的 Y坐标，然后计算出移动了几个索引</span></span><br><span class="line">    <span class="keyword">let</span> touchMove = e.touches[<span class="number">0</span>].pageY</span><br><span class="line">    <span class="keyword">this</span>.touch.y2 = touchMove</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里的 16.7 是索引元素的高度</span></span><br><span class="line">    <span class="keyword">let</span> delta = <span class="built_in">Math</span>.floor((<span class="keyword">this</span>.touch.y2 - <span class="keyword">this</span>.touch.y1) / <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最后的位置</span></span><br><span class="line">    <span class="comment">// * 1 是因为 this.touch.anchorIndex 是字符串，用 * 1 偷懒的转化一下</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="keyword">this</span>.touch.anchorIndex * <span class="number">1</span> + delta</span><br><span class="line">    <span class="keyword">this</span>.scroll.scrollToElement(<span class="keyword">this</span>.$refs.listGroup[index])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以实现索引的功能了。</p><p>当然这样是不会满足我们的对不对，我们要加入炫酷的特效呀。比如索引高亮什么的~~</p><h2 id="移动内容索引高亮"><a href="#移动内容索引高亮" class="headerlink" title="移动内容索引高亮"></a>移动内容索引高亮</h2><p>emmm，这个时候就有点复杂啦。但是有耐心就可以看懂滴。</p><p>我们需要 better-scroll 的 on 方法，返回内容滚动时候的 Y轴偏移值。所以在初始化 better-scroll 的时候需要添加一下代码。对了，别忘了在 data 中添加一个 scrollY，和 currentIndex （用来记录高亮索引的位置）因为我们需要监听，所以在 data 中添加。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_initSrcoll () &#123;</span><br><span class="line">  <span class="keyword">this</span>.scroll = <span class="keyword">new</span> BScroll(<span class="keyword">this</span>.$refs.listView, &#123;</span><br><span class="line">    probeType: <span class="number">3</span>,</span><br><span class="line">    click: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听Y轴偏移的值</span></span><br><span class="line">  <span class="keyword">this</span>.scroll.on(<span class="string">'scroll'</span>, (pos) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.scrollY = pos.y</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后需要计算一下内容的高度，添加一个 calculateHeight() 方法，用来计算索引内容的高度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_calculateHeight () &#123;</span><br><span class="line">  <span class="keyword">this</span>.listHeight = []</span><br><span class="line">  <span class="keyword">const</span> list = <span class="keyword">this</span>.$refs.listGroup</span><br><span class="line">  <span class="keyword">let</span> height = <span class="number">0</span></span><br><span class="line">  <span class="keyword">this</span>.listHeight.push(height)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = list[i]</span><br><span class="line">    height += item.clientHeight</span><br><span class="line">    <span class="keyword">this</span>.listHeight.push(height)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, 760, 1380, 1720, 2340, 2680, 2880, 3220, 3420, 3620, 3960, 4090, 4920, 5190, 5320, 5590, 5790, 5990, 6470, 7090, 7500, 7910, 8110, 8870]</span></span><br><span class="line"><span class="comment">// 得到这样的值</span></span><br></pre></td></tr></table></figure><p>然后在 watch 中监听 scrollY，看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  scrollY (newVal) &#123;</span><br><span class="line">    <span class="comment">// 向下滑动的时候 newVal 是一个负数，所以当 newVal &gt; 0 时，currentIndex 直接为 0</span></span><br><span class="line">    <span class="keyword">if</span> (newVal &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentIndex = <span class="number">0</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算 currentIndex 的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.listHeight.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> height1 = <span class="keyword">this</span>.listHeight[i]</span><br><span class="line">      <span class="keyword">let</span> height2 = <span class="keyword">this</span>.listHeight[i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (-newVal &gt;= height1 &amp;&amp; -newVal &lt; height2) &#123;</span><br><span class="line">        <span class="keyword">this</span>.currentIndex = i</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当超 -newVal &gt; 最后一个高度的时候</span></span><br><span class="line">    <span class="comment">// 因为 this.listHeight 有头尾，所以需要 - 2</span></span><br><span class="line">    <span class="keyword">this</span>.currentIndex = <span class="keyword">this</span>.listHeight.length - <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到 currentIndex 的之后，在 html 中使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给索引绑定 class --&gt;  :class="&#123;'current': currentIndex === index&#125;"</span><br></pre></td></tr></table></figure><p>最后再处理一下滑动索引的时候改变 currentIndex。</p><p>因为代码可以重复利用，且需要处理边界情况，所以就把</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.scroll.scrollToElement(<span class="keyword">this</span>.$refs.listGroup[index])</span><br></pre></td></tr></table></figure><p>重新写了个函数，来减少代码量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 scrollToElement 的时候，改变 scrollY，因为有 watch 所以就会计算出 currentIndex</span></span><br><span class="line">scrollToElement (index) &#123;</span><br><span class="line">  <span class="comment">// 处理边界情况</span></span><br><span class="line">  <span class="comment">// 因为 index 通过滑动距离计算出来的</span></span><br><span class="line">  <span class="comment">// 所以向上滑超过索引框框的时候就会 &lt; 0，向上就会超过最大值</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; <span class="keyword">this</span>.listHeight.length - <span class="number">2</span>) &#123;</span><br><span class="line">    index = <span class="keyword">this</span>.listHeight.length - <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// listHeight 是正的， 所以加个 -</span></span><br><span class="line">  <span class="keyword">this</span>.scrollY = -<span class="keyword">this</span>.listHeight[index]</span><br><span class="line">  <span class="keyword">this</span>.scroll.scrollToElement(<span class="keyword">this</span>.$refs.listGroup[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lazyload"><a href="#lazyload" class="headerlink" title="lazyload"></a>lazyload</h2><p>lazyload 插件也顺便说一下哈，增加一下用户体验。</p><p><strong>使用方法</strong>  </p><ol><li>先 npm 安装</li><li>在 main.js 中 import，然后 Vue.use</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueLazyload <span class="keyword">from</span> <span class="string">'vue-lazyload'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">  loading: <span class="built_in">require</span>(<span class="string">'./common/image/default.jpg'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>添加一张 loading 图片，使用 webpack 的 require 获取图片。</p><ol start="3"><li>然后在需要使用的时候，把 <code>:src=&quot;&quot;</code> 换成 <code>v-lazy=&quot;&quot;</code> 就实现了图片懒加载的功能。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>移动端字母索引导航就这么实现啦，感觉还是很有难度的哈（对我来说）。</p><p>主要就是使用了 better-scroll 的 on 获取移动偏移值（实现高亮）、scrollToElement 跳转到相应的位置（实现跳转）。以及使用 touch 事件监听触摸，来获取开始的位置，以及滑动距离（计算最后的位置）。</p><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><ul><li>对 touch 事件有了了解</li><li>对 better-scroll 的使用熟练了一点</li><li>vue 也熟练也一点啦，emmm</li><li>以后再写这样的东西就有经验啦</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;vue&lt;/strong&gt; + &lt;strong&gt;better-scroll&lt;/strong&gt; 实现移动端歌手列表字母索引导航。算是一个学习笔记吧，写个笔记让自己了解的更加深入一点。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://caijin.tech/blog/tags/JavaScript/"/>
    
      <category term="移动端" scheme="http://caijin.tech/blog/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JS 中的 autoprefixer</title>
    <link href="http://caijin.tech/blog/2018/04/20/2018-4-20-autoprefix-style/"/>
    <id>http://caijin.tech/blog/2018/04/20/2018-4-20-autoprefix-style/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-05-02T06:16:11.396Z</updated>
    
    <content type="html"><![CDATA[<p>在编写 CSS 的时候，常常需要考虑游览器的兼容，需要给样式加上前缀。在 webpack 中直接写 CSS 的时候有 autoprefixer 插件帮我们自动添加，很方便。但是在 JS 中添加 CSS 的时候，插件就不起作用了，这个时候，就需要自己来添加了。所以可以实现一个函数，来为我们自动添加相应的游览器兼容前缀。<a id="more"></a></p><p>直接上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// elementStyle 是一个对象，包含了游览器支持的 style</span></span><br><span class="line"><span class="keyword">let</span> elementStyle = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>).style</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vendor = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 定义游览器前缀</span></span><br><span class="line">  <span class="keyword">let</span> transformNames = &#123;</span><br><span class="line">    webkit: <span class="string">'webkitTransform'</span>,</span><br><span class="line">    Moz: <span class="string">'MozTransform'</span>,</span><br><span class="line">    O: <span class="string">'OTransform'</span>,</span><br><span class="line">    ms: <span class="string">'msTransform'</span>,</span><br><span class="line">    standard: <span class="string">'transform'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历前缀，如果游览器支持的话，就返回对应 key</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> transformNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementStyle[transformNames[key]] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> key</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果都不支持，那肯定是有问题的，返回 false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把函数导出，然后直接使用 import 引用就行了</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">prefixStyle</span> (<span class="params">style</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vendor === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 vendor 为标准，就不改变 style</span></span><br><span class="line">  <span class="keyword">if</span> (vendor === <span class="string">'standard'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> style</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则返回 vender(也就是 webkit Moz O ms 中的一个) + 样式首字母大写</span></span><br><span class="line">  <span class="comment">// 例如：webkit + transform ---&gt; webkitTransform</span></span><br><span class="line">  <span class="keyword">return</span> vendor + style.charAt(<span class="number">0</span>).toUpperCase() + style.substr(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，使用 createElement() 方法得到 Element 对象，然后得到游览器支持的 style 样式。</p><p>然后使用一个立即执行函数，来获取到样式前缀。</p><p>然后导出一个 prefixStyle 函数，需要使用的时候直接 import 导入就可以了。</p><p>使用的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先引入 prefixStyle 函数</span></span><br><span class="line"><span class="keyword">import</span> &#123;prefixStyle&#125; <span class="keyword">from</span> <span class="string">'common/js/dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后定义我们的样式</span></span><br><span class="line"><span class="comment">// 得到的 transfrom 就是加上前缀之后的样式</span></span><br><span class="line"><span class="keyword">const</span> transform = prefixStyle(<span class="string">'transform'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="built_in">document</span>.querySelector(<span class="string">'.box'</span>)</span><br><span class="line">m.style[transform] = <span class="string">'scale(2)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果我们的游览器是 webkit 内核，那么上面的代码就等于</span></span><br><span class="line">m.style[<span class="string">'webkitTransform'</span>] = <span class="string">'scale(2)'</span></span><br></pre></td></tr></table></figure><p>例如，游览器用的是 webkit 内核，那么 prefixStyle(‘transform’) 就可以得到 webkitTransform。</p><p>这样就很方便的给样式加上了前缀，因为使用了模块化的思想，所以可以很方便的重复使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编写 CSS 的时候，常常需要考虑游览器的兼容，需要给样式加上前缀。在 webpack 中直接写 CSS 的时候有 autoprefixer 插件帮我们自动添加，很方便。但是在 JS 中添加 CSS 的时候，插件就不起作用了，这个时候，就需要自己来添加了。所以可以实现一个函数，来为我们自动添加相应的游览器兼容前缀。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://caijin.tech/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS 正则表达式</title>
    <link href="http://caijin.tech/blog/2018/04/15/2018-04-15-regexp-record/"/>
    <id>http://caijin.tech/blog/2018/04/15/2018-04-15-regexp-record/</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2018-04-24T12:25:38.661Z</updated>
    
    <content type="html"><![CDATA[<p>因为自己的正则学的真的不是很好，所以重新学习一边，顺便记录一下，以备复习。<a id="more"></a></p><h3 id="正则工具"><a href="#正则工具" class="headerlink" title="正则工具"></a>正则工具</h3><p>推荐这款正则的工具，Github：<a href="https://github.com/javallone/regexper-static" target="_blank" rel="noopener">Regexper</a>，用图片解释的正则，很方便很实用。因为是国外的网站，有时候会上不去，所以推荐下载下来本地运行，这样会比较方便。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>字面量: <code>var reg = /\bis\b/g;</code></li><li>构造函数：<code>var reg = new RegExp(&#39;\\d\\w\\d&#39;, &#39;g&#39;)</code></li></ul><p>使用构造函数的时候需要注意 <code>\</code> 反斜杠是需要转义的。</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li>g：global 全文匹配</li><li>i： ignoreCase 或略大小写</li><li>m: multiline 换行符当成新的一行</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d/gim</span></span><br><span class="line">reg.global</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">reg.global = <span class="literal">false</span></span><br><span class="line">reg.global</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>修饰符默认都是 false，而且都是只读的，只能在创建的时候确认，创建之后是无法修改的。</p><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p><strong>[]</strong>：[abc] 代表 a、b、c 中的一个匹配就可以。</p><h3 id="字符类取反向"><a href="#字符类取反向" class="headerlink" title="字符类取反向"></a>字符类取反向</h3><p><strong>^</strong>：取反向类。</p><h3 id="范围类"><a href="#范围类" class="headerlink" title="范围类"></a>范围类</h3><p><strong>[a-z]</strong>：从 a 到 z 的任意字符，这是个<strong>闭区间</strong>，然后 [a-zA-Z] 可以连写。</p><h3 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h3><ul><li><code>.</code>：等价于 [^\r\n] 除了回车符和换行符之外的所有字符</li><li><code>\d</code>：等价于 [0-9] 数字字符</li><li><code>\D</code>：非数字字符</li><li><code>\s</code>：[\t\n\x0B\f\r] 空白符</li><li><code>\S</code>：非空白符</li><li><code>\w</code>：等价于 [a-zA-Z_0-9] 单词字符（字母、数字、下划线）</li><li><code>\W</code>：非单词字符</li></ul><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><ul><li><code>^</code>：以xxx开头 /^@./</li><li><code>$</code>：以xxx结尾 /.@$/</li><li><code>\b</code>：单词边界</li></ul><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><ul><li><code>?</code>：出现0次或1次（最多出现一次）</li><li><code>+</code>：出现1次或多次（至少出现一次）</li><li><code>*</code>：出现0次或多次</li><li><code>{n}</code>：出现n次</li><li><code>{n,m}</code>：出现n到m次</li><li><code>{n,}</code>：至少出现n次</li></ul><h3 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h3><p>正则表达式会匹配尽量多的值，直到匹配失败。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'12345678'</span>.replace(<span class="regexp">/\d&#123;3,6&#125;/</span>, <span class="string">'M'</span>)</span><br><span class="line"><span class="comment">// "M78"</span></span><br></pre></td></tr></table></figure><h3 id="非贪婪模式"><a href="#非贪婪模式" class="headerlink" title="非贪婪模式"></a>非贪婪模式</h3><p>如果要取消贪婪模式，只需要在量词后面加一个问号 <code>/\d{4,6}?/</code>。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'12345678'</span>.replace(<span class="regexp">/\d&#123;3,6&#125;?/</span>, <span class="string">'M'</span>)</span><br><span class="line"><span class="comment">// "M45678"</span></span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>使用  () 可以达到分组功能<br><code>abcd{4} ----&gt; (abcd){4}</code></p><h4 id="分组捕获"><a href="#分组捕获" class="headerlink" title="分组捕获"></a>分组捕获</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'2011-01-12'</span>.replace(<span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>, <span class="string">'$2--$3--$1'</span>)</span><br><span class="line"><span class="comment">// '01--12--2011'</span></span><br></pre></td></tr></table></figure><h4 id="忽略分组"><a href="#忽略分组" class="headerlink" title="忽略分组"></a>忽略分组</h4><p>不希望捕获某些分组，只需要在分组内加上 <code>? :</code>，就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'2011-01-12'</span>.replace(<span class="regexp">/(?:\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>, <span class="string">'$2--$3--$1'</span>)</span><br><span class="line"><span class="comment">// '12--$3--01'</span></span><br></pre></td></tr></table></figure><h3 id="或"><a href="#或" class="headerlink" title="或"></a>或</h3><p>可以用 | 达到效果，<code>Byron | Casper</code>，使用分组来不干涉其他表达式。<br><code>BBry(on|CA)sper</code></p><h3 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h3><p>正则表达式从文本头部向尾部开始解析，所以文本的尾部方向，称之为“前”（这个理解起来有点难，我想了好久）。所谓<strong>前瞻</strong>就是正则在匹配到规则的时候，向前检查是否符合断言。（其实还有后顾，但是 JS 暂时好像没有支持）。</p><h4 id="正向前瞻-exp-assert"><a href="#正向前瞻-exp-assert" class="headerlink" title="正向前瞻 exp(?=assert)"></a>正向前瞻 exp(?=assert)</h4><p>正向前瞻指的就是，表达式匹配以后还需要向前检查是否符合（正向）断言（assert）。例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a2*34v8'</span>.replace(<span class="regexp">/\w(?=\d)/g</span>, <span class="string">'X'</span>)</span><br><span class="line"><span class="comment">// 'X2*X4X8'</span></span><br></pre></td></tr></table></figure></p><h4 id="反向前瞻-exp-assert"><a href="#反向前瞻-exp-assert" class="headerlink" title="反向前瞻 exp(?!assert)"></a>反向前瞻 exp(?!assert)</h4><p>反向前瞻指的就是，表达式匹配以后还需要向前检查是否不符合（反向）断言（assert）。例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a2*34v8'</span>.replace(<span class="regexp">/\w(?!\d)/g</span>, <span class="string">'X'</span>)</span><br><span class="line"><span class="comment">// 'aX*3XvX'</span></span><br></pre></td></tr></table></figure></p><h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><h3 id="RegExp-prototype-test-str"><a href="#RegExp-prototype-test-str" class="headerlink" title="RegExp.prototype.test(str)"></a>RegExp.prototype.test(str)</h3><p>用于测试字符串参数中是否存在匹配正则表达式模式的字符串，存在返回 true，否则返回 false。  </p><p><strong>非全局 （没g）</strong><br>当不使用全局的时候，test() 方法会直接返回 true，或者 false。</p><p><strong>全局 （有g）</strong><br>这个时候就会被 lastIndex（当前匹配结果的，最后一个字符的，下一个字符） 影响了，因为每次匹配之后，它的 lastIndex 都会改变，这时候就会影响到 test() 方法的结果。看例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\w/g</span></span><br><span class="line"><span class="keyword">while</span>(reg.test(<span class="string">'ab'</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reg2.lastIndex)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>当但三次循环的时候，因为 lastIndex 为 2 所以就直接返回了 false，循环结束。</p><h3 id="RegExp-prototype-exec-str"><a href="#RegExp-prototype-exec-str" class="headerlink" title="RegExp.prototype.exec(str)"></a>RegExp.prototype.exec(str)</h3><p>使用正则对字符串执行搜索，并将更新全局 RegExp 对象的属性以反映匹配结果。</p><ul><li>如果没有匹配返回 null，否则返回一个结果数组<ul><li>index 声明匹配文本的第一个字符的位置</li><li>input 存放被检索的字符串 string</li></ul></li></ul><p><strong>非全局 （没g）</strong>  </p><ul><li>第一个元素是相匹配的文本</li><li>第二个元素是与 正则 的第一个字表达式相匹配的文本（如果有的话）</li><li>第三个就是与 正则 的第二个字表达式相匹配的文本（如果有有），以此类推<br>例子：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/\d\w\d/.exec(<span class="string">'a1b2c3d4e5'</span>)</span><br><span class="line"><span class="comment">// ["1b2", index: 1, input: "a1b2c3d4e5", groups: undefined]</span></span><br><span class="line"></span><br><span class="line">/\d(\w)\d/.exec(<span class="string">'a1b2c3d4e5'</span>)</span><br><span class="line"><span class="comment">// ["1b2", "b", index: 1, input: "a1b2c3d4e5", groups: undefined]</span></span><br><span class="line"></span><br><span class="line">/\d(\w)(\d)/.exec(<span class="string">'a1b2c3d4e5'</span>)</span><br><span class="line"><span class="comment">// ["1b2", "b", "2", index: 1, input: "a1b2c3d4e5", groups: undefined]</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>全局（有g）</strong>  </p><p>直接看例子吧：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ts = <span class="string">'a1b2c3d4e5'</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d(\w)(\d)/g</span></span><br><span class="line"><span class="keyword">let</span> ret</span><br><span class="line"><span class="keyword">while</span> (ret = reg.exec(ts)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["1b2", "b", "2", index: 1, input: "a1b2c3d4e5", groups: undefined]</span></span><br><span class="line"><span class="comment">// ["3d4", "d", "4", index: 5, input: "a1b2c3d4e5", groups: undefined]</span></span><br></pre></td></tr></table></figure></p><h3 id="String-prototype-search-reg"><a href="#String-prototype-search-reg" class="headerlink" title="String.prototype.search(reg)"></a>String.prototype.search(reg)</h3><ul><li>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。</li><li>方法返回第一个匹配结果 index，查找不到返回 -1。</li><li>search() 方法不执行全局匹配，它将忽略标志 g，并且总是从字符串的开始进行检索。</li></ul><h3 id="String-prototype-match-reg"><a href="#String-prototype-match-reg" class="headerlink" title="String.prototype.match(reg)"></a>String.prototype.match(reg)</h3><ul><li>match() 方法将检索字符串，以找到一个或多个与 regexp 匹配的文本。</li><li>regexp 是否具有标志 g 对结果影响很大！</li></ul><p><strong>非全局 （没g）</strong></p><ul><li>返回数组的第一个元素存放的匹配文本，而其余的元素存放的是与正则表达式的字表达式匹配的文本。</li><li>除了常规的数组元素之外，返回的数组还含有 2 个对象属性。<ul><li>index 声明位置</li><li>inpu 声明对 stringObject 的引用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a1a2b3c4d5e'</span>.match(<span class="regexp">/\d(\w)\d/</span>)</span><br><span class="line"> <span class="comment">// ["1a2", "a", index: 1, input: "a1a2b3c4d5e", groups: undefined]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>全局（有g）</strong></p><ul><li>全局检索，找到所有字符串中的所有匹配字符串<ul><li>没有找到任何匹配，返回 null</li><li>如果找到了一个或多个匹配，返回一个数组</li></ul></li><li>数组元素中存放的是字符串中所有的匹配子字符串，不包含 index 和 input</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a1a2b3c4d5e'</span>.match(<span class="regexp">/\d(\w)\d/g</span>)</span><br><span class="line"><span class="comment">// ["1a2", "3c4"]</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-split-reg"><a href="#String-prototype-split-reg" class="headerlink" title="String.prototype.split(reg)"></a>String.prototype.split(reg)</h3><p>一般的使用：<code>&#39;a,b,c,d&#39;.split(&#39;,&#39;); ---&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]&#39;</code></p><p><strong>使用正则</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a1a2b3c4d5e'</span>.split(<span class="regexp">/\d/</span>)</span><br><span class="line"><span class="comment">// ["a", "a", "b", "c", "d", "e"]</span></span><br></pre></td></tr></table></figure></p><h3 id="String-prototype-replace-reg"><a href="#String-prototype-replace-reg" class="headerlink" title="String.prototype.replace(reg)"></a>String.prototype.replace(reg)</h3><p>replace 的第二个值可以传入 function 来处理复杂的替换。</p><p><strong>function参数含义</strong>：function 会在每次匹配替换的时候调用，有四个参数。返回值就是替换的内容。</p><ol><li>匹配字符串</li><li>正则表达式分组内容，没有分组则没有该参数</li><li>匹配项在字符串中的 index</li><li>原字符串</li></ol><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子1：没有分组</span></span><br><span class="line"><span class="string">'a1a2b3c4d5e'</span>.replace(<span class="regexp">/\d/g</span>, (match, index, o) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(match) + <span class="number">5</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// "a6a7b8c9d10e"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子2：有分组</span></span><br><span class="line"><span class="string">'a1a2b3c4d5e'</span>.replace(<span class="regexp">/(\d)\w(\d)/g</span>, (match, g1, g2, index, o) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> g1 + g2</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// "a12b34d5e"</span></span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>使用正则来实现一个时间的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入一个实例化后的时间，以及需要的时间格式，如 yyyy-mm-dd</span></span><br><span class="line"><span class="comment">// new Date()，会返回一个Date对象的实例。如果不加参数，实例代表的就是当前时间。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formaDate</span> (<span class="params">date, fmt</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 找到 y 字符，然后替换成年</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/(y+)/i</span>.test(fmt)) &#123;</span><br><span class="line">    fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (date.getFullYear() + <span class="string">''</span>).substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$<span class="number">1.</span>length))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="string">'M+'</span>: date.getMonth() + <span class="number">1</span>,</span><br><span class="line">    <span class="string">'d+'</span>: date.getDate(),</span><br><span class="line">    <span class="string">'h+'</span>: date.getHours(),</span><br><span class="line">    <span class="string">'m+'</span>: date.getMinutes(),</span><br><span class="line">    <span class="string">'s+'</span>: date.getSeconds()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="comment">// 找到相应字符，然后进行替换</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`(<span class="subst">$&#123;k&#125;</span>)`</span>, <span class="string">'i'</span>).test(fmt)) &#123;</span><br><span class="line">      <span class="keyword">let</span> str = o[k] + <span class="string">''</span></span><br><span class="line">      fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (m) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 是否需要补全0，例如 8:5 --&gt; 08:05</span></span><br><span class="line">        <span class="comment">// 如果需要，则使用 substr 方法操作</span></span><br><span class="line">        <span class="keyword">if</span> (m.length === <span class="number">2</span>) &#123;          </span><br><span class="line">          str = (<span class="string">'00'</span> + str).substr(str.length)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fmt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后我们只需要传入实例化的时间，以及时间的格式，就可以返回符合格式的时间，非常的方便</span></span><br><span class="line">formaDate(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">'yyyy-mm-dd hh:mm'</span>)</span><br><span class="line"><span class="comment">// "2018-04-15 20:02"</span></span><br><span class="line">formaDate(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">'mm-dd-yyyy'</span>)</span><br><span class="line"><span class="comment">// "04-15-2018"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为自己的正则学的真的不是很好，所以重新学习一边，顺便记录一下，以备复习。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://caijin.tech/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于 JavaScript 中的复制数组</title>
    <link href="http://caijin.tech/blog/2018/04/05/2018-04-05-copying-arrays-in-javascript/"/>
    <id>http://caijin.tech/blog/2018/04/05/2018-04-05-copying-arrays-in-javascript/</id>
    <published>2018-04-04T16:00:00.000Z</published>
    <updated>2018-04-24T11:00:31.458Z</updated>
    
    <content type="html"><![CDATA[<p>之前在写扫雷的时候，因为需要用到二维数组，当时就在复制数组这里出现了问题，所以记录一下。<a id="more"></a></p><p>当我们在需要复制数组的时候一定需要注意，<strong>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</strong>我们来看例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [5, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>arr2</code> 并不是 <code>arr1</code> 的克隆，而是指向同一份数据的另一个指针。修改 <code>arr2</code>，会直接导致 <code>arr1</code> 的变化。</p><p>那么如果正确的复制数组呢？可以使用 <a href="http://www.w3school.com.cn/jsref/jsref_concat_array.asp" target="_blank" rel="noopener">concat()</a> 用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个<strong>副本</strong>。看例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.concat()</span><br><span class="line">arr1[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>因为 <code>concat()</code> 返回的是一个副本，所以这个时候改变 <code>arr1</code> 就不会导致 <code>arr2</code> 改变了。</p><p><strong>还可以利用 ES6 中的扩展运算符来复制数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span>  arr2 = [...arr1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> [...arr2] = arr1;</span><br></pre></td></tr></table></figure><p>参考资料：<a href="http://es6.ruanyifeng.com/#docs/array#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%BA%94%E7%94%A8" target="_blank" rel="noopener">阮一峰ES6入门：扩展运算符的应用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在写扫雷的时候，因为需要用到二维数组，当时就在复制数组这里出现了问题，所以记录一下。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://caijin.tech/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>实现居中的几种方法</title>
    <link href="http://caijin.tech/blog/2018/03/25/2018-03-25-css-center/"/>
    <id>http://caijin.tech/blog/2018/03/25/2018-03-25-css-center/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2018-04-25T07:11:03.696Z</updated>
    
    <content type="html"><![CDATA[<p>在开发的过程中，很多时候我们需要实现居中，所以记录一下几种居中的方法。<a id="more"></a></p><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h3 id="text-align-center"><a href="#text-align-center" class="headerlink" title="text-align: center;"></a>text-align: center;</h3><p><code>text-align: center</code> 居中是<strong>只针对行内元素</strong>的，例如 span、a、img、input 、text 等行内元素。 </p><p>我们有这样的 HTML 结构：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>inline element<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>行内居中只需要给父元素设置 <code>text-align: center</code> 就可以实现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：对于元素中的块级元素它是不起作用的。但是可以把块级元素的 <code>display</code> 设置为 <code>inline-block 或者 inline</code> 之后，也是可以生效的，但是需要注意设置 <code>inline</code> 之后是会丢失一些功能的，比如设置元素的宽高。</p><h3 id="margin-0-auto"><a href="#margin-0-auto" class="headerlink" title="margin: 0 auto;"></a>margin: 0 auto;</h3><p>通过给自身设置 <code>margin: 0 auto</code> 可以实现对<strong>块级元素</strong>的居中。例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"chilren"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.chilren</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和 <code>text-align: center</code> 一样，它也可以改变行内元素的 <code>display</code> 为 <code>inline-block</code> 来实现行内元素的居中。</p></blockquote><h3 id="positon-absolute"><a href="#positon-absolute" class="headerlink" title="positon: absolute;"></a>positon: absolute;</h3><p>使用 <code>absolute</code> 也是可以实现居中的。<strong>但是使用它之后，子元素就不能把父元素撑起来了。需要自己确定父元素的大小。</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"chilren"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.chilren</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-50%);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先给父元素添加 <code>position: relative</code> 这样子元素就可以通过父元素来实现绝对定位。然后让元素向右偏移 50%，需要注意，<strong>这个时候居中的是子元素的左边线</strong>。所以这时候就需要使用 <code>transilateX(-50%)</code> 让元素再相对自己向左移 50%（自身的 50%），这样就能完美实现居中啦。（这个方法在垂直居中的时候同样适用）</p><h3 id="display-flex"><a href="#display-flex" class="headerlink" title="display: flex;"></a>display: flex;</h3><p>使用弹性布局也可以很方便的实现水平居中（和垂直居中）。</p><p>看下例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"chilren"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.chilren</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 flex 来实现居中真的很方便，也是网页布局的一大利器~好用的不得了。对于 flex 不了解的，可以参考阮一峰老师的这篇文章：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a>。</p><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="positon-absolute-和-display-flex"><a href="#positon-absolute-和-display-flex" class="headerlink" title="positon: absolute; 和 display: flex;"></a>positon: absolute; 和 display: flex;</h3><p>这两个方法用来实现垂直居中也是非常方便的。</p><h4 id="positon-absolute-1"><a href="#positon-absolute-1" class="headerlink" title="positon: absolute;"></a>positon: absolute;</h4><p>通过决定定位实现垂直居中的方法和实现水平居中基本没什么两样，只需要向下偏移 50%，然后相对自身向上偏移 50% 就可以了。看代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"chilren"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.chilren</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-50%, -50%, 0);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边使用了 <code>translate3d</code> 这个属性，三个值分别对应了 x、y、z 轴方向的位移。这样我们就完美的实现元素的居中啦~</p><h4 id="margin-top-50"><a href="#margin-top-50" class="headerlink" title="margin-top: 50%;"></a>margin-top: 50%;</h4><p>根据绝对定位实现居中，也可以联想到使用 <code>margin-top: 50%</code> 和 <code>transform: translateY(-50%)</code> 来实现垂直居中，道理是差不多的。代码就不放了，相信会使用绝对定位实现居中的就会这个啦。</p><h4 id="display-flex-1"><a href="#display-flex-1" class="headerlink" title="display: flex;"></a>display: flex;</h4><p>这个很简单，直接看代码吧。看过阮一峰老师文章就懂了，写的很详细，我就不多赘述了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"chilren"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.chilren</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="line-height-实现文字的垂直居中"><a href="#line-height-实现文字的垂直居中" class="headerlink" title="line-height 实现文字的垂直居中"></a>line-height 实现文字的垂直居中</h3><p>因为行高的垂直居中性，所以在行内的元素都是会居中的。那么使用 <code>line-height</code> 等于父元素高度也可以实现元素的居中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"chilren"</span>&gt;</span>啦啦啦，line-height<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.chilren</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在实现文字垂直居中的时候是非常方便的。</p><p>暂时就先记录这么多常用的居中方法，以后有其他好用的方法的话会进行补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发的过程中，很多时候我们需要实现居中，所以记录一下几种居中的方法。
    
    </summary>
    
    
      <category term="CSS" scheme="http://caijin.tech/blog/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>原生 JavaScript 实现扫雷游戏</title>
    <link href="http://caijin.tech/blog/2018/03/22/2018-03-22-mine-sweeping/"/>
    <id>http://caijin.tech/blog/2018/03/22/2018-03-22-mine-sweeping/</id>
    <published>2018-03-22T09:15:35.000Z</published>
    <updated>2018-05-02T14:17:50.603Z</updated>
    
    <content type="html"><![CDATA[<p>学习了这么长时间的 JS，不能光看不练，于是就写了个小游戏练习一下。因为自己还是个菜鸟，所以有错误的话还请各位大佬多多指点，谢谢啦~ <a id="more"></a></p><p>如果感兴趣的话可以试试：<a href="http://caijin.tech/demo/mineSweeping/index.html">Demo</a><br>项目地址：<a href="https://github.com/CaiJinyc/game-mineSweepinng" target="_blank" rel="noopener">game-mineSweepinng</a></p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><h4 id="扫雷过程"><a href="#扫雷过程" class="headerlink" title="扫雷过程"></a>扫雷过程</h4><p>扫呀扫呀扫个雷。<br><img src="http://hexo-image.oss-cn-shenzhen.aliyuncs.com/18-5-2/30416056.jpg" alt=""></p><h4 id="扫雷失败"><a href="#扫雷失败" class="headerlink" title="扫雷失败"></a>扫雷失败</h4><p>扫雷失败就会提示扫雷失败，然后逐步显示出所有地雷（我会说我没找到地雷的图才用的炸弹吗）。<br><img src="http://hexo-image.oss-cn-shenzhen.aliyuncs.com/18-5-2/37179305.jpg" alt=""></p><h4 id="扫雷成功"><a href="#扫雷成功" class="headerlink" title="扫雷成功"></a>扫雷成功</h4><p>其实这里是有个动画的，彩色方块是逐步覆盖全部格子的。<br><img src="http://hexo-image.oss-cn-shenzhen.aliyuncs.com/18-5-2/34681198.jpg" alt=""></p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h4 id="实现的功能"><a href="#实现的功能" class="headerlink" title="实现的功能"></a>实现的功能</h4><p>基本扫雷的功能都实现了，例如：</p><ul><li>计时</li><li>选择游戏难度</li><li>标记地雷（插旗子标记地雷，标记之后不能点击）</li><li>剩余雷数（总的雷数减去插旗的数量）</li><li>自动连锁点开（当点开某个区块后，如果该区块的数字为 0，也就是九宫格内没有雷，那么将自动点开九宫格内的所有区块）</li></ul><p>还做了点小彩蛋，例如：踩到地雷时，地雷会逐步显示，还有成功扫到所有雷之后，地图逐渐被彩色方块覆盖，然后提示扫雷成功。</p><h4 id="没有实现的功能"><a href="#没有实现的功能" class="headerlink" title="没有实现的功能"></a>没有实现的功能</h4><p>自定义，问号标记（偷懒了偷懒了，说不定以后会补上呢 <em>（鬼才会信吧）</em>）。</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>都说写东西学的最快，这句话是很有道理的。写个小游戏，我又 Get 到了很多知识。</p><h4 id="生成一张扫雷地图"><a href="#生成一张扫雷地图" class="headerlink" title="生成一张扫雷地图"></a>生成一张扫雷地图</h4><p>这里当然用的是数组啦，会玩扫雷的应该都懂，如果一个方块块有雷，那么边上的值都加 1（就是根据这个扫的嘛~没有这个还怎么玩）。我相信很多人是不会像看代码的，所以我直接讲我的思路。</p><ol><li>根据行数和列数创建一个多维数组（使用 for 循环嵌套实现）</li><li>然后使用 Math 随机 map[x][x] 来写入雷的位置（再次使用 for 循环，写入 9（9 就代表雷）），如果位置已经有雷了就重写随机然后写入</li><li>然后我们就会得到一个这样的数组，这个时候我们只需要让 9 的四周加上 1<br>[ [0, 9, 0, 0],<br>  [0, 0, 9, 0],<br>  [9, 0, 9, 0],<br>  [0, 9, 0, 0] ]</li><li>得到这样的数组，这样就大功告成啦。<br>[  [1, 9, 2, 1],<br>  [2, 4, 9, 2],<br>  [9, 4, 9, 2],<br>  [2, 9, 2, 1]  ]</li></ol><h4 id="将地图写入页面"><a href="#将地图写入页面" class="headerlink" title="将地图写入页面"></a>将地图写入页面</h4><p>使用 doucument.querySelector 获取到元素节点，然后使用 innerHTML 就行了。（感觉自己说这两句像是在放屁）。想了解的直接去 Github 看源码把，一看就懂。</p><h4 id="自动连锁点开"><a href="#自动连锁点开" class="headerlink" title="自动连锁点开"></a>自动连锁点开</h4><p>这个比较难，想了挺久的。思路大概是这样：</p><ol><li>点击到为 0 的位置，就自动显示周围一圈的位置。</li><li>然后周围一圈的还有为 0 的位置，就继续显示周围一圈，然后循环到没有为止。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习了这么长时间的 JS，不能光看不练，于是就写了个小游戏练习一下。因为自己还是个菜鸟，所以有错误的话还请各位大佬多多指点，谢谢啦~
    
    </summary>
    
    
      <category term="游戏" scheme="http://caijin.tech/blog/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
</feed>
