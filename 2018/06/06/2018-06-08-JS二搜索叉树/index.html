<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript 二叉搜索树 · CaiJinyc's Blog</title><meta name="description" content="JavaScript 二叉搜索树 - CaiJinyc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon.ico"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://caijin.tech/blog/atom.xml" title="CaiJinyc's Blog"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/blog/avatar.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/CaiJinyc" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript 二叉搜索树</h1><div class="post-info">2018年6月6日</div><div class="post-content"><blockquote>
<p> 本文包括：二叉搜索树（创建、遍历、搜索、插入等）、JavaScript 实现翻转二叉树<br><a id="more"></a></p>
</blockquote>
<h2 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h2><p><strong>二叉树的定义：</strong>二叉树的每个结点至多只有二棵子树（不存在度大于2的结点），二叉树的子树有左右之分，次序不能颠倒。</p>
<p><strong>二叉查找树（BST）：</strong>又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉查找树是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。</p>
<h2 id="创建一个二叉查找树"><a href="#创建一个二叉查找树" class="headerlink" title="创建一个二叉查找树"></a>创建一个二叉查找树</h2><p>首先创建一个 <code>BinarySearchTree</code> 类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了 ES6 的 Class 语法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node(key) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> right = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      key,</span><br><span class="line">      left,</span><br><span class="line">      right</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下二叉查找树的数据结构组织方式（没有找到二叉搜索树的先用二叉树的代替一下）：</p>
<p><img src="http://p87llnk7g.bkt.clouddn.com/18-6-8/86417615.jpg" alt=""></p>
<p>二叉树是通过指针（指向下一个节点）来表示节点之间的关系的，所以需要在声明 Node 的时候，定义两个指针，一个指向左边，一个指向右边。 还需要声明一个 root 来保存树的根元素。</p>
<h2 id="向树中插入一个键（节点）"><a href="#向树中插入一个键（节点）" class="headerlink" title="向树中插入一个键（节点）"></a>向树中插入一个键（节点）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>  </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  insert (key) &#123;</span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="keyword">this</span>.Node(key)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果根节点为空，那么插入的节点就为根节点</span></span><br><span class="line">      <span class="keyword">this</span>.root = newNode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果根节点不为空</span></span><br><span class="line">      <span class="keyword">this</span>.insertNode(<span class="keyword">this</span>.root, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  insertNode (node, newNode) &#123;</span><br><span class="line">    <span class="comment">// 当新节点比父节点小，插入左边</span></span><br><span class="line">    <span class="keyword">if</span> (newNode.key &lt; node.key) &#123;</span><br><span class="line">      <span class="comment">// 左边没有内容则插入</span></span><br><span class="line">      <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.left = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有内容就继续递归，直到没有内容然后可以插入</span></span><br><span class="line">        <span class="keyword">this</span>.insertNode(node.left, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 右边和左边相同，不重复说明</span></span><br><span class="line">      <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.right = newNode</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.insertNode(node.right, newNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为使用了 class 所以没有学过 class 的同学可以先看一下 ES6 的 class，再来看文章。</p>
<p>仔细分析上面的代码，多看几遍就可以了解其中的奥妙（也可以自己在游览器中运行一下，插入几个值试一下）。</p>
<p>运行一遍试一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> BinarySearchTree()</span><br><span class="line">m.insert(<span class="number">5</span>)</span><br><span class="line">m.insert(<span class="number">4</span>)</span><br><span class="line">m.insert(<span class="number">3</span>)</span><br><span class="line">m.insert(<span class="number">6</span>)</span><br><span class="line">m.insert(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<p>会得到这样的结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  key: <span class="number">5</span>,</span><br><span class="line">  left: &#123;</span><br><span class="line">    key: <span class="number">4</span>,</span><br><span class="line">    left: &#123;</span><br><span class="line">      key: <span class="number">3</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    right: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  right: &#123;</span><br><span class="line">    key: <span class="number">6</span>,</span><br><span class="line">    left: <span class="literal">null</span>,</span><br><span class="line">    right: &#123;</span><br><span class="line">      key: <span class="number">7</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emmm，真复杂（自己看的都头晕），还是画个图吧。</p>
<p><img src="http://p87llnk7g.bkt.clouddn.com/18-6-8/17343352.jpg" alt=""></p>
<p>会生成这样一个二叉查找树~，插入功能就算完成啦！</p>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。访问树会有三种方法：中序、先序、后续。下面分别讲解</p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是从最小到最大的顺序进行访问所有节点。具体方法，看代码吧，配上图多看两遍代码就能明白了（我是这么认为的）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>  </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  inOrderTraverse (callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.inOrderTraverseNode(<span class="keyword">this</span>.root, callback)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  inOrderTraverseNode (node, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.inOrderTraverseNode(node.left, callback)</span><br><span class="line">      callback(node.key)</span><br><span class="line">      <span class="keyword">this</span>.inOrderTraverseNode(node.right, callback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，用图展示一下遍历的过程，具体过程看代码多思考一下。</p>
<p><img src="http://p87llnk7g.bkt.clouddn.com/18-6-8/62900257.jpg" alt=""></p>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p>先序遍历会先访问节点本身，然后再访问它的左侧子节点，最后再访问右侧的节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>  </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  preOrderTraverse (callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.preOrderTraverseNode(<span class="keyword">this</span>.root, callback)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  preOrderTraverseNode (node, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      callback(node.key)</span><br><span class="line">      <span class="keyword">this</span>.preOrderTraverseNode(node.left, callback)</span><br><span class="line">      <span class="keyword">this</span>.preOrderTraverseNode(node.right, callback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细看代码，发现和中序遍历的区别不过是先执行了 <code>callback</code> 然后再遍历左右。</p>
<p><img src="http://p87llnk7g.bkt.clouddn.com/18-6-8/3812727.jpg" alt=""></p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历则是先访问节点的后代节点，然后再访问节点本身。实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>  </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  postOrderTraverse (callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.postOrderTraverseNode(<span class="keyword">this</span>.root, callback)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  postOrderTraverseNode (node, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.postOrderTraverseNode(node.left, callback)</span><br><span class="line">      <span class="keyword">this</span>.postOrderTraverseNode(node.right, callback)</span><br><span class="line">      callback(node.key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再仔细看代码，发现和中序遍历的区别不过是先执行了遍历了左右，最后执行了 <code>callback</code> 。</p>
<p>惯例，画张图~</p>
<p><img src="http://p87llnk7g.bkt.clouddn.com/18-6-8/67391855.jpg" alt=""></p>
<p>三种遍历方式讲完啦，不懂的可以多看几遍代码哦~</p>
<h2 id="搜索二叉搜索树中的值"><a href="#搜索二叉搜索树中的值" class="headerlink" title="搜索二叉搜索树中的值"></a>搜索二叉搜索树中的值</h2><p>在树中，通常有三种经常使用的搜索类型：</p>
<ul>
<li>搜索最大值</li>
<li>搜索最小值</li>
<li>搜索特定值</li>
</ul>
<p>下面一一列举</p>
<h3 id="搜索最小和最大值"><a href="#搜索最小和最大值" class="headerlink" title="搜索最小和最大值"></a>搜索最小和最大值</h3><p>首先我们知道二叉搜索树中的最小值在最左边，最大值在最右边。既然知道这个，那么实现搜索最大和最小就十分简单了。所以直接上代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>  </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 搜索最小</span></span><br><span class="line">  min () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.minNode(<span class="keyword">this</span>.root)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  minNode (node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="comment">// 如果节点存在，而且左边不为 null</span></span><br><span class="line">      <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> node.key</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果树为空，则返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 搜索最大</span></span><br><span class="line">  max () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.maxNode(<span class="keyword">this</span>.root)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  maxNode (node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="keyword">while</span> (node &amp;&amp; node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.right</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node.key</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搜索特定的值"><a href="#搜索特定的值" class="headerlink" title="搜索特定的值"></a>搜索特定的值</h3><p>基本上的思路和遍历节点差不多，具体看代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>  </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略前面的</span></span><br><span class="line">  </span><br><span class="line">  search (key) &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">this</span>.searchNode(<span class="keyword">this</span>.root, key)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  searchNode (node, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 key 比节点的值小，那么搜索左边的子节点，下面的相反</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(node.left, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(node.right, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>未完待续。</p>
</div></article></div></main><footer><div class="paginator"><a href="/blog/2018/05/25/2018-5-25-event-bind/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'caijinyc';
var disqus_identifier = '2018/06/06/2018-06-08-JS二搜索叉树/';
var disqus_title = 'JavaScript 二叉搜索树';
var disqus_url = 'http://caijin.tech/blog/2018/06/06/2018-06-08-JS二搜索叉树/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//caijinyc.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://caijin.tech/blog">CaiJinyc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>